<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess vs AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            width: 95%;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            margin: 0;
            color: #2c3e50;
        }
        
        .game-area {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }
        
        .board-container {
            width: 500px;
            max-width: 100%;
        }
        
        .info-container {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .status-box {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .move-history {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .move-history ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        
        .move-history li {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .difficulty-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        @media (max-width: 900px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .board-container, .info-container {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Chess vs AI</h1>
        </div>
        
        <div class="game-area">
            <div class="board-container">
                <div id="board"></div>
            </div>
            
            <div class="info-container">
                <div class="status-box">
                    <h3>Game Status</h3>
                    <p id="status">Your turn (White)</p>
                    <p id="thinking" style="display: none;">AI is thinking...</p>
                </div>
                
                <div class="move-history">
                    <h3>Move History</h3>
                    <ul id="moves"></ul>
                </div>
                
                <div class="controls">
                    <button id="new-game">New Game</button>
                    <button id="undo-move">Undo Move</button>
                    <button id="hint">Get Hint</button>
                    
                    <div class="difficulty-selector">
                        <label for="difficulty">AI Difficulty:</label>
                        <select id="difficulty">
                            <option value="1">Beginner</option>
                            <option value="2" selected>Intermediate</option>
                            <option value="3">Advanced</option>
                            <option value="4">Magnus Carlsen</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize the chess game
        let game = new Chess();
        let board = null;
        let moveHistory = [];
        
        // Board configuration
        const config = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
        };
        
        // Initialize the board
        board = Chessboard('board', config);
        
        // Prevent dragging pieces when it's not the player's turn or game is over
        function onDragStart(source, piece) {
            // Do not pick up pieces if the game is over
            if (game.game_over()) return false;
            
            // Only pick up white pieces (player is white)
            if (piece.search(/^b/) !== -1) return false;
        }
        
        // Handle the piece drop
        function onDrop(source, target) {
            // See if the move is legal
            const move = game.move({
                from: source,
                to: target,
                promotion: 'q' // Always promote to a queen for simplicity
            });
            
            // Illegal move
            if (move === null) return 'snapback';
            
            // Update move history
            updateMoveHistory(move);
            
            // Make AI move after a short delay
            $('#thinking').show();
            setTimeout(makeAIMove, 500);
        }
        
        // Update the board position after the piece snap animation
        function onSnapEnd() {
            board.position(game.fen());
        }
        
        // Make a move for the AI
        function makeAIMove() {
            // Get all possible moves
            const possibleMoves = game.moves();
            
            // Game over
            if (possibleMoves.length === 0) {
                updateStatus();
                $('#thinking').hide();
                return;
            }
            
            // Get difficulty level
            const difficulty = parseInt($('#difficulty').val());
            let move;
            
            // Simple AI based on difficulty
            if (difficulty === 1) {
                // Random move for beginner
                const randomIdx = Math.floor(Math.random() * possibleMoves.length);
                move = game.move(possibleMoves[randomIdx]);
            } else if (difficulty === 4) {
                // Magnus Carlsen level - much deeper search and better evaluation
                move = findGrandmasterMove();
            } else {
                // For intermediate and advanced, use a slightly smarter approach
                move = findBestMove(difficulty);
            }
            
            // Update the board
            board.position(game.fen());
            
            // Update move history
            updateMoveHistory(move);
            
            // Update game status
            updateStatus();
            $('#thinking').hide();
        }
        
        // Grandmaster level move finding (Magnus Carlsen mode)
        function findGrandmasterMove() {
            const MAX_DEPTH = 4; // Deeper search for better moves
            
            function minimax(depth, alpha, beta, isMaximizingPlayer) {
                if (depth === 0) {
                    return evaluatePositionGrandmaster(game.board());
                }

                const possibleMoves = game.moves();
                
                if (possibleMoves.length === 0) {
                    // Checkmate or stalemate
                    if (game.in_check()) {
                        return isMaximizingPlayer ? -10000 : 10000; // Checkmate
                    }
                    return 0; // Stalemate
                }
                
                // Sort moves to improve alpha-beta pruning efficiency
                possibleMoves.sort(() => 0.5 - Math.random());
                
                if (isMaximizingPlayer) {
                    let bestValue = -Infinity;
                    for (let i = 0; i < possibleMoves.length; i++) {
                        game.move(possibleMoves[i]);
                        bestValue = Math.max(bestValue, minimax(depth - 1, alpha, beta, false));
                        game.undo();
                        alpha = Math.max(alpha, bestValue);
                        if (beta <= alpha) break; // Alpha-beta pruning
                    }
                    return bestValue;
                } else {
                    let bestValue = Infinity;
                    for (let i = 0; i < possibleMoves.length; i++) {
                        game.move(possibleMoves[i]);
                        bestValue = Math.min(bestValue, minimax(depth - 1, alpha, beta, true));
                        game.undo();
                        beta = Math.min(beta, bestValue);
                        if (beta <= alpha) break; // Alpha-beta pruning
                    }
                    return bestValue;
                }
            }
            
            const possibleMoves = game.moves();
            let bestMove = null;
            let bestValue = -Infinity;
            let alpha = -Infinity;
            let beta = Infinity;
            
            for (let i = 0; i < possibleMoves.length; i++) {
                game.move(possibleMoves[i]);
                const value = minimax(MAX_DEPTH - 1, alpha, beta, false);
                game.undo();
                
                if (value > bestValue) {
                    bestValue = value;
                    bestMove = possibleMoves[i];
                }
                alpha = Math.max(alpha, bestValue);
            }
            
            return game.move(bestMove);
        }
        
        // Advanced evaluation function for grandmaster level
        function evaluatePositionGrandmaster(board) {
            let totalEvaluation = 0;
            
            // Piece values (standard chess values)
            const pieceValue = {
                'p': 100,
                'n': 320,
                'b': 330,
                'r': 500,
                'q': 900,
                'k': 20000
            };
            
            // Piece-Square tables for positional understanding
            const pawnTable = [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5,  5, 10, 25, 25, 10,  5,  5],
                [0,  0,  0, 20, 20,  0,  0,  0],
                [5, -5,-10,  0,  0,-10, -5,  5],
                [5, 10, 10,-20,-20, 10, 10,  5],
                [0,  0,  0,  0,  0,  0,  0,  0]
            ];
            
            const knightTable = [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ];
            
            const bishopTable = [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0,  5, 10, 10,  5,  0,-10],
                [-10,  5,  5,  5,  5,  5,  5,-10],
                [-10,  0,  5,  0,  0,  5,  0,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ];
            
            const rookTable = [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [5, 10, 10, 10, 10, 10, 10,  5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [0,  0,  0,  5,  5,  0,  0,  0]
            ];
            
            const queenTable = [
                [-20,-10,-10, -5, -5,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5,  5,  5,  5,  0,-10],
                [-5,  0,  5,  5,  5,  5,  0, -5],
                [0,  0,  5,  5,  5,  5,  0, -5],
                [-10,  5,  5,  5,  5,  5,  0,-10],
                [-10,  0,  5,  0,  0,  0,  0,-10],
                [-20,-10,-10, -5, -5,-10,-10,-20]
            ];
            
            const kingMiddleTable = [
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-20,-30,-30,-40,-40,-30,-30,-20],
                [-10,-20,-20,-20,-20,-20,-20,-10],
                [20, 20,  0,  0,  0,  0, 20, 20],
                [20, 30, 10,  0,  0, 10, 30, 20]
            ];
            
            const kingEndTable = [
                [-50,-40,-30,-20,-20,-30,-40,-50],
                [-30,-20,-10,  0,  0,-10,-20,-30],
                [-30,-10, 20, 30, 30, 20,-10,-30],
                [-30,-10, 30, 40, 40, 30,-10,-30],
                [-30,-10, 30, 40, 40, 30,-10,-30],
                [-30,-10, 20, 30, 30, 20,-10,-30],
                [-30,-30,  0,  0,  0,  0,-30,-30],
                [-50,-30,-30,-30,-30,-30,-30,-50]
            ];
            
            // Count material and apply positional bonuses
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece !== null) {
                        // Material value
                        let value = pieceValue[piece.type];
                        
                        // Positional value
                        if (piece.type === 'p') {
                            value += pawnTable[piece.color === 'b' ? i : 7 - i][j];
                        } else if (piece.type === 'n') {
                            value += knightTable[piece.color === 'b' ? i : 7 - i][j];
                        } else if (piece.type === 'b') {
                            value += bishopTable[piece.color === 'b' ? i : 7 - i][j];
                        } else if (piece.type === 'r') {
                            value += rookTable[piece.color === 'b' ? i : 7 - i][j];
                        } else if (piece.type === 'q') {
                            value += queenTable[piece.color === 'b' ? i : 7 - i][j];
                        } else if (piece.type === 'k') {
                            // Use different tables for middle and endgame
                            const isEndgame = isEndGame(board);
                            if (isEndgame) {
                                value += kingEndTable[piece.color === 'b' ? i : 7 - i][j];
                            } else {
                                value += kingMiddleTable[piece.color === 'b' ? i : 7 - i][j];
                            }
                        }
                        
                        totalEvaluation += piece.color === 'b' ? value : -value;
                    }
                }
            }
            
            return totalEvaluation;
        }
        
        // Helper function to determine if we're in an endgame
        function isEndGame(board) {
            let queens = 0;
            let minors = 0;
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece !== null) {
                        if (piece.type === 'q') queens++;
                        if (piece.type === 'n' || piece.type === 'b') minors++;
                    }
                }
            }
            
            return queens === 0 || (queens === 2 && minors <= 2);
        }
        
        // Simple AI to find the best move
        function findBestMove(difficulty) {
            const possibleMoves = game.moves();
            let bestMove = null;
            let bestValue = -9999;
            
            for (let i = 0; i < possibleMoves.length; i++) {
                const move = possibleMoves[i];
                game.move(move);
                
                // Evaluate position
                const value = evaluateBoard(game.board(), difficulty);
                game.undo();
                
                if (value > bestValue) {
                    bestValue = value;
                    bestMove = move;
                }
            }
            
            return game.move(bestMove);
        }
        
        // Simple board evaluation function
        function evaluateBoard(board, difficulty) {
            let totalEvaluation = 0;
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    totalEvaluation += getPieceValue(board[i][j], i, j, difficulty);
                }
            }
            
            return totalEvaluation;
        }
        
        // Get the value of a piece
        function getPieceValue(piece, x, y, difficulty) {
            if (piece === null) {
                return 0;
            }
            
            // Basic piece values
            const pieceValue = {
                'p': 10,
                'n': 30,
                'b': 30,
                'r': 50,
                'q': 90,
                'k': 900
            };
            
            // For advanced difficulty, add position-based evaluation
            let positionBonus = 0;
            if (difficulty === 3) {
                // Center control bonus for pawns and knights
                if (piece.type === 'p' || piece.type === 'n') {
                    const centerDistance = Math.abs(3.5 - x) + Math.abs(3.5 - y);
                    positionBonus = (4 - centerDistance) * 0.5;
                }
            }
            
            const absoluteValue = pieceValue[piece.type] + positionBonus;
            return piece.color === 'b' ? absoluteValue : -absoluteValue;
        }
        
        // Update the move history display
        function updateMoveHistory(move) {
            moveHistory.push(move);
            
            const moveNumber = Math.ceil(moveHistory.length / 2);
            let moveText;
            
            if (move.color === 'w') {
                moveText = `${moveNumber}. ${move.san}`;
            } else {
                moveText = `${move.san}`;
            }
            
            $('#moves').append(`<li>${moveText}</li>`);
            
            // Scroll to bottom of move history
            const moveHistoryElement = document.querySelector('.move-history');
            moveHistoryElement.scrollTop = moveHistoryElement.scrollHeight;
        }
        
        // Update the game status display
        function updateStatus() {
            let status = '';
            
            if (game.in_checkmate()) {
                status = game.turn() === 'w' ? 'Game over, AI wins!' : 'Game over, you win!';
            } else if (game.in_draw()) {
                status = 'Game over, drawn position';
            } else {
                status = game.turn() === 'w' ? 'Your turn (White)' : 'AI is thinking...';
                
                if (game.in_check()) {
                    status += ', ' + (game.turn() === 'w' ? 'You are' : 'AI is') + ' in check';
                }
            }
            
            $('#status').text(status);
        }
        
        // New game button
        $('#new-game').on('click', function() {
            game.reset();
            board.position('start');
            moveHistory = [];
            $('#moves').empty();
            updateStatus();
        });
        
        // Undo move button
        $('#undo-move').on('click', function() {
            if (moveHistory.length >= 2) {
                game.undo(); // Undo AI's move
                game.undo(); // Undo player's move
                
                // Remove the last two moves from history
                moveHistory.pop();
                moveHistory.pop();
                
                // Update the display
                $('#moves').empty();
                moveHistory.forEach(move => {
                    const moveNumber = Math.ceil((moveHistory.indexOf(move) + 1) / 2);
                    let moveText;
                    
                    if (move.color === 'w') {
                        moveText = `${moveNumber}. ${move.san}`;
                    } else {
                        moveText = `${move.san}`;
                    }
                    
                    $('#moves').append(`<li>${moveText}</li>`);
                });
                
                board.position(game.fen());
                updateStatus();
            }
        });
        
        // Hint button
        $('#hint').on('click', function() {
            // Save current position
            const currentFen = game.fen();
            
            // Find a good move
            const hintMove = findBestMove(1); // Use lowest difficulty for hint
            
            // Restore position
            game.load(currentFen);
            
            // Highlight the suggested move
            board.position(game.fen());
            
            // Show hint message
            $('#status').text(`Hint: Consider moving ${hintMove.from} to ${hintMove.to}`);
        });
        
        // Initialize status
        updateStatus();
    </script>
</body>
</html>
